/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//#define MCU_Act_As_Master
#define MCU_Act_As_Slave


#include "stm32f103x6.h"
#include "stm32f103c6_EXTI_driver.h"
#include "stm32f103c6_gpio_driver.h"
#include "stm32f103c6_USART_driver.h"
#include "stm32f103c6_SPI_driver.h"


void clock_init(){
	RCC_EN_CLK_GPIOA();
	RCC_EN_CLK_GPIOB();
	RCC_EN_CLK_AFIO();
}


unsigned ch;


void SPI_IRQ_Callback(struct S_IRQ_SPI irq_src){

#ifdef MCU_Act_As_Slave
	if(irq_src.RXNE){
		MCAL_SPI_Tx_Rx(SPI1, &ch , Polling_disable);
		MCAL_USART_SendData(USART1, &ch, enable);
	}
	#endif

}

void UART_IRQ_Callback(void){

	MCAL_USART_ReceiveData(USART1, &ch, disable);
	MCAL_USART_SendData(USART1, &ch, enable);
	MCAL_GPIO_WritePin(GPIOA,GPIO_PIN_4, 0);
	 MCAL_SPI_Tx_Rx(SPI1, &ch, Polling_enable);
	MCAL_GPIO_WritePin(GPIOA,GPIO_PIN_4, 1);

}

int main(void){

	clock_init();

//	==============================================
//	UART

	USART_Config_t UARTCFG;
	UARTCFG.BaudRate = USART_BaudRate_115200;
	UARTCFG.HwFlowCtl = USART_HwFlowCtl_NONE;
	UARTCFG.IRQ_EN = USART_IRQ_EN_RXNEIE;
	UARTCFG.P_IRQ_CallBack = UART_IRQ_Callback ;
	UARTCFG.Parity = USART_Parity_NONE;
	UARTCFG.Payload_Length = USART_Payload_Length_8B;
	UARTCFG.StopBits = USART_StopBits_1;
	UARTCFG.USART_Mode = USART_Mode_Tx_RX;

	MCAL_USART_Init(USART1, &UARTCFG);
	MCAL_USART_GPIO_Set_Pins(USART1);

//	==================================================
//	SPI

	SPI_Config_t SPI1CFG;

	SPI1CFG.CLKPhase = SPI_CLKPhase_2EDGE_1DATA_capture;

	SPI1CFG.CLKPolarity = SPI_CLKPolarity_HIGH_idel;

	SPI1CFG.Data_Size = SPI_Data_Size_8B ;

	SPI1CFG.Frame_Format = SPI_Frame_Format_MSB_SEND_FIRST ;

	SPI1CFG.SPI_BAUDRATE_PS = SPI_BAUDRATE_PS_8;

	SPI1CFG.Comm_Mode = SPI_Comm_Mode_2LINES ;


#ifdef MCU_Act_As_Master
	SPI1CFG.Device_Mode = SPI_Device_MODE_MASTER ;
	SPI1CFG.IRQ_EN = SPI_IRQ_EN_NONE;
	SPI1CFG.NSS = SPI_NSS_SOFTWARE_Internal_SET ;
	SPI1CFG.P_IRQ_CallBack = NULL;

	//	config ss on PA4 by gpio
		GPIO_PinConfig_t PINCFG;
		PINCFG.GPIO_PinNumber = GPIO_PIN_4 ;
		PINCFG.GPIO_Mode = GPIO_MODE_OUTPUT_PP ;
		PINCFG.GPIO_OutputSpeed = GPIO_SPEED_10;
		MCAL_GPIO_Init(GPIOA, &PINCFG);

	//	set slave select high (idel)
		MCAL_GPIO_WritePin(GPIOA,GPIO_PIN_4, 1);
#endif

#ifdef MCU_Act_As_Slave
	SPI1CFG.Device_Mode = SPI_Device_MODE_SLAVE ;
	SPI1CFG.IRQ_EN = SPI_IRQ_EN_RXNEIE;
	SPI1CFG.NSS = SPI_NSS_HARDWARE_SLAVE ;
	SPI1CFG.P_IRQ_CallBack = SPI_IRQ_Callback;


#endif

	MCAL_SPI_Init(SPI1, &SPI1CFG) ;

	MCAL_SPI_Set_Pins(SPI1);



	while(1){
	}

}
